# ZK証明回路での計算量分析

## 現在のアルゴリズムのZK回路変換の問題

### 現在の処理（csi_processor.py）

```python
# 1. FFT計算
fft_df = apply_fourier_transform(df)  # O(N log N) per subcarrier

# 2. コサイン類似度計算
similarity = cosine_similarity(current_fft, baseline_fft)
# 公式: cos(θ) = (A·B) / (||A|| * ||B||)
# 内積、ノルム、除算が必要

# 3. ソート
sorted_subcarriers = sorted(similarities.items(), key=lambda x: x[1])
```

### ZK回路での制約（Constraint）数の見積もり

**前提:**
- サブキャリア数: 200個（80MHz帯）
- データポイント: 6,000点（60秒 @ 100Hz）
- ZK-SNARKs（Groth16）を想定

#### 1. FFT計算の制約数

```
FFT: O(N log N) の演算
N = 6,000点の場合:
  - 加算/減算: 約 6,000 * log₂(6,000) ≈ 76,000回
  - 乗算: 約 38,000回

R1CS制約数（1サブキャリアあたり）:
  - 加算: 無料（線形結合）
  - 乗算: 各1制約 → 約38,000制約

全サブキャリア（200個）:
  38,000 × 200 = 7,600,000制約 ❌ 非常に大きい
```

#### 2. コサイン類似度計算の制約数

```python
# cos(θ) = (A·B) / (||A|| * ||B||)
#
# A·B: 内積計算
# ||A||: ノルム計算（平方和の平方根）
# 除算: 逆数計算

# 1サブキャリアペアあたり:
dot_product = sum(a[i] * b[i])  # N回の乗算 = N制約
norm_a = sqrt(sum(a[i]^2))      # N回の二乗 + 1回の平方根
norm_b = sqrt(sum(b[i]^2))      # N回の二乗 + 1回の平方根
division = dot_product / (norm_a * norm_b)  # 除算 ≈ 約200制約（反復法）

# N=6,000の場合、1サブキャリアあたり:
6,000 (内積) + 6,000×2 (ノルム) + 200 (除算) = 約18,200制約

# 全サブキャリア（200個）:
18,200 × 200 = 3,640,000制約 ❌ 非常に大きい
```

#### 3. ソート処理の制約数

```
比較ベースのソート: O(N log N)回の比較
N = 200サブキャリアの場合:
  - 比較回数: 約 200 * log₂(200) ≈ 1,500回
  - 1回の比較: 約100制約（条件分岐のエミュレート）

総制約数: 1,500 × 100 = 150,000制約 ⚠️ 中程度
```

### 総制約数の見積もり

```
FFT:              7,600,000制約
コサイン類似度:    3,640,000制約
ソート:             150,000制約
その他（前処理等）:  100,000制約
─────────────────────────────────
合計:           約11,490,000制約 ❌❌❌
```

### 証明生成時間とメモリの見積もり

**ZK-SNARK (Groth16) の場合:**
- 制約数 1,000,000あたり:
  - Proving time: 約30秒〜2分（GPU使用）
  - メモリ使用: 約8〜16GB
  - Setup（trusted setup）: 1回のみ、数時間

**11,490,000制約の場合:**
- Proving time: **約6〜20分** ⚠️
- メモリ使用: **約90〜180GB** ❌
- Setup時間: **数日** ❌

### 実用上の限界

一般的なZKアプリケーションの制約数:
- 小規模: 10,000〜100,000制約（数秒で証明生成）
- 中規模: 100,000〜1,000,000制約（数十秒で証明生成）
- 大規模: 1,000,000〜10,000,000制約（数分で証明生成、高スペックマシン必要）

**現在のアルゴリズムは大規模の上限を超えており、実用的ではない。**

---

## ZK証明に適したアルゴリズムへの変更案

### 案1: 固定パターン選択（最も軽量）

```python
# 事前に最適なサブキャリアインデックスを決定
FIXED_SUBCARRIER_INDICES = [45, 67, 89, 123, 156]

# ZK回路内での処理
selected_subcarriers = [csi_data[i] for i in FIXED_SUBCARRIER_INDICES]

# 制約数: 0（選択自体は計算なし）
# 証明内容: 「指定されたインデックスのデータを抽出した」
```

**利点:**
- ZK回路での制約数: ほぼゼロ
- 証明生成: 瞬時
- 検証: 非常に高速

**欠点:**
- 環境変化に適応できない
- 最適性が保証されない

---

### 案2: 振幅ベース上位N個選択（軽量）

```python
# 各サブキャリアの平均振幅を計算
amplitudes = [mean(abs(subcarrier)) for subcarrier in csi_data]

# 上位5個を選択（ソート不要、argmax的手法）
selected_indices = find_top_k(amplitudes, k=5)

# 制約数見積もり:
# - 振幅計算: 200サブキャリア × 約10制約 = 2,000制約
# - Top-k選択: 約5,000制約（比較ネットワーク）
# 合計: 約7,000制約 ✓ 実用的
```

**ZK回路実装例（疑似コード）:**
```rust
// Circom疑似コード
template SelectTopKSubcarriers(N, K, M) {
    signal input csi_data[N][M];  // N=200, M=6000
    signal output selected_indices[K];

    // 各サブキャリアの平均振幅を計算
    component avg[N];
    signal amplitudes[N];
    for (var i = 0; i < N; i++) {
        avg[i] = Average(M);
        for (var j = 0; j < M; j++) {
            avg[i].in[j] <== abs(csi_data[i][j]);
        }
        amplitudes[i] <== avg[i].out;
    }

    // Top-K選択（比較ネットワーク）
    component topk = BitonicTopK(N, K);
    topk.values <== amplitudes;
    selected_indices <== topk.indices;
}
```

**制約数:** 約7,000〜20,000制約（実装による）
**証明時間:** 1秒以下
**メモリ:** 1GB以下

---

### 案3: ハッシュベース決定論的選択

```python
# デバイスID、タイムスタンプ、環境パラメータからハッシュ生成
seed = hash(device_id + timestamp + location)

# 疑似乱数で決定論的に選択
selected_indices = deterministic_sample(seed, k=5, max_index=200)

# 制約数:
# - ハッシュ計算（SHA256）: 約25,000制約
# - サンプリング: 約1,000制約
# 合計: 約26,000制約 ✓ 実用的
```

---

### 案4: 2段階証明（ハイブリッド方式）

**オンチェーン（ZK回路内）:**
```python
# 軽量な前処理のみ証明
1. CSIデータの完全性証明（Merkle proof）
2. データ範囲の正当性証明
3. 固定/簡易アルゴリズムでサブキャリア選択
```

**オフチェーン（従来の計算）:**
```python
# 重い計算は通常の処理
4. FFT計算
5. コサイン類似度計算（必要に応じて）
6. 詳細な呼吸数推定
```

**証明内容:**
- 「入力データが改ざんされていない」
- 「選択アルゴリズムが正しく実行された」
- 「結果が特定の範囲内にある」

**制約数:** 10,000〜50,000制約
**証明時間:** 数秒

---

## 推奨アプローチ

### 目的に応じた選択

| 目的 | 推奨アルゴリズム | 制約数 | 証明時間 |
|------|-----------------|--------|----------|
| データ完全性証明 | Merkle tree + 固定選択 | 5,000 | <1秒 |
| 選択の正当性証明 | 振幅ベースTop-K | 20,000 | 1-2秒 |
| プライバシー保護 | ハッシュベース選択 | 26,000 | 2-3秒 |
| 高精度な分析 | 2段階証明（軽量ZK + オフチェーン） | 50,000 | 5秒 |

---

## 実装への影響

### 変更が必要な箇所

1. **サブキャリア選択アルゴリズムの変更**
   - `analysis/csi_processor.py:262-281` を軽量アルゴリズムに置き換え

2. **ZK回路の実装**
   - Circom、Noir、Halo2などのフレームワークで回路を記述

3. **証明生成の統合**
   - エッジデバイスまたはサーバーで証明を生成
   - 証明データをメタデータに含める

### データフロー（ZK対応版）

```
エッジデバイス（Raspberry Pi）
    ├─ CSIデータ収集
    ├─ 軽量アルゴリズムでサブキャリア選択
    ├─ ZK証明生成 ← 新規
    │   - 選択の正当性を証明
    │   - データ完全性を証明
    └─ PCAPファイル + 証明データ
        ↓
サーバー
    ├─ ZK証明の検証 ← 新規（高速）
    ├─ 検証成功後、データ処理
    ├─ 呼吸数推定
    └─ ローカル保存
```

---

## 次のステップ

1. **要件定義**
   - ZK証明で何を証明したいか明確化
   - プライバシー保護？データ完全性？計算の正当性？

2. **アルゴリズム選定**
   - 上記の案から最適なものを選択
   - プロトタイプ実装とベンチマーク

3. **ZKフレームワーク選定**
   - Circom（ZK-SNARK）
   - Noir（Aztec）
   - Halo2（ZK-STARK）
   - RISC Zero（ZK-VM）

4. **統合設計**
   - 既存システムとの統合方法
   - 証明生成・検証のタイミング

---

## 結論

**現在のFFT+コサイン類似度アルゴリズムをそのままZK回路化するのは非現実的です。**

制約数: 約1,150万（メモリ180GB、証明時間20分）

**推奨: 振幅ベースTop-K選択への変更**

制約数: 約2万（メモリ1GB以下、証明時間1秒）

精度は若干低下する可能性がありますが、ZK証明の実用性が大幅に向上します。
